depth = rep(c("CV-selected Max Depth", all_depths_names), each = nrow(T_preds_by_depth)),
Method = "T-learner",
Covariate = W1,
trueCATE = trueCATE
)
##########
## GET EP-learner Predictions
##########
# Get eP-learner preds for CV and by tree depth
ep_stack <- Stack$new(
Lrnr_cate_EP$new(base_learner  = lrnr_stack, sieve_num_basis = 1),
Lrnr_cate_EP$new(base_learner  = lrnr_stack, sieve_num_basis = 2),
Lrnr_cate_EP$new(base_learner  = lrnr_stack, sieve_num_basis = 3),
Lrnr_cate_EP$new(base_learner  = lrnr_stack, sieve_num_basis = 4),
Lrnr_cate_EP$new(base_learner  = lrnr_stack, sieve_num_basis = 5.)
)
# train learners
lrnr_EP <- cross_validate_cate(ep_stack, hte3_task)
lrnr_EP_cv <- lrnr_EP$lrnr_sl
lrnr_EP_stack <- lrnr_EP_cv$fit_object$full_fit$fit_object$learner_fits$Stack
# get predictions
ep_preds_all <- lrnr_EP_stack$predict(hte3_task)
ep_preds_cv <- lrnr_EP_cv$predict(hte3_task)
# extract best pred for each depth (CV over sieves)
lrnr_names <- names(ep_preds_all)
tree_depth <- stringr::str_match(lrnr_names, "_30_([0-9]+)")[,2]
sieve_num <- stringr::str_match(lrnr_names, "EP_([0-9]+)")[,2]
cv_risks <- lrnr_EP$cv_risk
all_depths <- unique(tree_depth)
best_index_by_depth <-c()
for(depth in all_depths) {
best_index <- as.vector(which(tree_depth == depth & cv_risks ==  min(cv_risks[tree_depth == depth])  ))
best_index_by_depth <- c(best_index_by_depth, best_index)
}
names(best_index_by_depth) <- all_depths
all_depths_names <- paste0("Max Depth = ", all_depths)
ep_preds_by_depth <- ep_preds_all[, best_index_by_depth, with = FALSE]
# collect predictions
EP_preds <- data.table(
preds = c(ep_preds_cv, unlist(ep_preds_by_depth)),
depth = rep(c("CV-selected Max Depth", all_depths_names), each = nrow(ep_preds_by_depth)),
Method = "EP-learner",
Covariate = W1,
trueCATE = trueCATE
)
real_preds <- data.table(preds = trueCATE,
depth = rep(c("CV-selected Max Depth", all_depths_names), each = length(trueCATE)),
Method = "TRUE",
Covariate = W1,
trueCATE = trueCATE)
# get all preds and bound in [-1,1]
all_preds <- as.data.frame(rbindlist(list(EP_preds, DR_preds, T_preds , real_preds)))
all_preds$preds <- pmax(all_preds$preds, -1)
all_preds$preds <- pmin(all_preds$preds, 1)
all_preds_sub <- all_preds[  all_preds$depth %in%  paste0("Max Depth = ", c(1,2,4,7)),]
color_palette <- c("#0000FF", "#FF0000", "#339933", "black")
linetype_palette <-c("solid", "dashed", "dotdash", "dotted")
size_palette <- c(0.7,0.65, 0.65, 0.7)
names(color_palette) <- names(linetype_palette) <- names(size_palette) <- c("EP-learner", "DR-learner", "T-learner", "TRUE")
plt <- ggplot(all_preds_sub) +
geom_line(aes(x = Covariate,
y = preds, color = Method, linetype = Method ,size = Method) )  + scale_x_continuous(limits=c(-3,3)) + labs(x = "Covariate", y = "CATE")  + scale_y_continuous(limits = c(-1, 1) ) + theme_bw() + facet_grid(~ depth )+ scale_colour_manual(values = color_palette)+ scale_linetype_manual(values=linetype_palette)  +  scale_size_manual(  values=size_palette )  +
theme(legend.position="none")
ggsave(file = "introDRlearner_bydepth.pdf", width = 9, height = 4)
all_preds_cv <- all_preds[  all_preds$depth %in% c("CV-selected Max Depth"),]
plt <- ggplot(all_preds_cv) +
geom_line(aes(x = Covariate,
y = preds, color = Method, linetype = Method ,size = Method) )  + scale_x_continuous(limits=c(-3,3)) + labs(x = "Covariate", y = "CATE")  + theme_bw() + facet_grid(~ depth )+ scale_colour_manual(values = color_palette)+ scale_linetype_manual(values=linetype_palette)  +  scale_size_manual(  values=size_palette )  + theme(legend.margin=margin(t=0, r=1, b=-1.5, l=1, unit="cm")) + scale_y_continuous(limits = c(-0.5, 0.5)) + facet_grid(~ depth )+
theme(legend.key.size = unit(1.5, 'cm'), #change legend key size
legend.key.height = unit(1.5, 'cm'), #change legend key height
legend.key.width = unit(1.5, 'cm'), #change legend key width
legend.title =  element_blank(), #change legend title font size
legend.text = element_text(size=13),
axis.text = element_text(size = 15),
axis.title = element_text(size = 20))   + geom_histogram(aes(x=Covariate))  +  geom_density(aes(x=Covariate, y = ..density..), color = NA, fill = "grey", alpha = 0.3)
plt
all_preds <- as.data.table(all_preds)
mse <- all_preds[,   mean((preds - trueCATE)^2), by = c("depth", "Method")]
setkey(mse, depth)
mse
real_preds
sigma_beta <- function(psi, beta=1/2){
c_beta <- 1/log((1+exp(beta)) / (1+exp(-beta)))
out <- c_beta * log((1+exp(beta*psi))/(1+exp(-beta)))
return(out)
}
psi <- seq(-1,1,length.out=100)
sigma_beta <- function(psi, beta=1/2){
c_beta <- 1/log((1+exp(beta)) / (1+exp(-beta)))
out <- c_beta * log((1+exp(beta*psi))/(1+exp(-beta)))
return(out)
}
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=everything(),
names_to="beta",
values_to="sigma_beta"
)
library(tidyverse)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=everything(),
names_to="beta",
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_ptypes = integer(),
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_ptypes = as.integer(),
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.integer(),
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.integer,
values_to="sigma_beta"
)
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.integer,
values_to="sigma_beta"
) %>%
ggplot()+
geom_line(aes(x=psi,y=sigma_beta,color=beta))
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.factor,
values_to="sigma_beta"
) %>%
ggplot()+
geom_line(aes(x=psi,y=sigma_beta,color=beta))
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
sigma_beta_2=sigma_beta(psi,beta=0.5)
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.factor,
values_to="sigma_beta"
) %>%
ggplot()+
geom_line(aes(x=psi,y=sigma_beta,color=beta))
tibble(
psi=seq(-1,1,length.out=10)
) %>%
mutate(
sigma_beta_1=sigma_beta(psi,beta=1),
sigma_beta_2=sigma_beta(psi,beta=2),
sigma_beta_0.5=sigma_beta(psi,beta=0.5)
) %>%
pivot_longer(
cols=!psi,
names_to="beta",
names_prefix="sigma_beta_",
names_transform = as.factor,
values_to="sigma_beta"
) %>%
ggplot()+
geom_line(aes(x=psi,y=sigma_beta,color=beta))
set.seed(2025)
setwd("~/Documents/PhD/Project 1 - Policy learning - Constraints - Multiple outcome/simulations_new_approach_AC")
library(tidyverse)
library(dplyr)
library(kernlab)
library(lbfgs)
library(tidyverse)
library(dplyr)
source("src/plot_fcts.R")
source("src/tool_box.R")
source("src/synthetic_data.R")
source("src/general_obj_fcts.R")
############################
##### Data generation #####
############################
#### General parameters ####
# Number of individuals
n <- 1e3
# Setting
setting<- "Other_1"
#"IVF_1" #"IVF_2" #"Other_2"
# Constraint-tolerance parameter
alpha<- 0.1 #0.5 #0.1 #0.05
epsilon <- 0.1
#### Generate synthetic data ####
option <- option_det(setting,"_")
exp <- data_gen(n,option)
df_complete<- exp[[1]]
###
true_cate_Y <- (df_complete$y1-df_complete$y0)
true_cate_Z <- df_complete$p1-df_complete$p0
### Plot synthetic_setting scenario
synthetic_setting_plot(df_complete, option)
# Grid search candidates
## Beta
beta_values <- seq(1e-6,2, 0.08)
## Lambda
lambda_values <- seq(0,10,0.1)
pi_opt <- ifelse(true_cate_Y>0,1,0)
mean(pi_opt*df_complete$y1 + (1-pi_opt)*df_complete$y0)
# Optimization: Find the x that minimizes the objective for each lambda
library(optimx)
results <- expand.grid(lambda = lambda_values, beta = beta_values, optimal_x = NA, risk = NA, constraint=NA, obj=NA, policy_value=NA)
covariates <- df_complete %>% select(starts_with("X"))
results$optimal_x <- vector("list", nrow(results))
for (beta in beta_values) {
for (lambda in lambda_values) {
# Get the current row index for this (lambda, beta) pair
idx <- which(results$lambda == lambda & results$beta == beta)
optim_result <- optim(
par = delta_Y(covariates, option),
fn = function(x) L(x, covariates, lambda, option, beta, alpha),
method = "L-BFGS-B",
lower = -1, upper = 1
)
# Store results
results$optimal_x[[idx]] <- optim_result$par
results$risk[idx] <- R_p0(optim_result$par, covariates, option)
results$constraint[idx] <- S_p0(optim_result$par, covariates, option, beta)
results$obj[idx] <- L(optim_result$par, covariates, lambda, option, beta, alpha)
results$policy_value[idx] <- policy_values(optim_result$par, c(df_complete$y1,df_complete$y0), beta)
# Stop increasing lambda if constraint is met
if (results$constraint[idx] < -epsilon) {
break  # Exit the loop for this beta, move to the next beta
}
}
}
results <- na.omit(results)
write.csv(results %>% select(-optimal_x), paste0("opt_results/",setting,".csv"))
results
res <- results %>% filter(constraint<=0)
idx_opt_pol <- which(results$policy_value==max(results %>%filter(constraint<=0) %>% select(policy_value)))
idx_opt_obj <- which(results$obj==max(results %>%filter(constraint<=0) %>% select(obj)))
idx_opt <- idx_opt_pol
idx_opt
idx_opt_pol <- which(results$policy_value==max(results %>%filter(constraint<=0) %>% select(policy_value)))
idx_opt_pol
idx_opt_pol[q]
idx_opt_pol[1]
results$lambda[idx_opt_pol[1]]
results$beta[idx_opt_pol[1]]
results$beta[idx_opt_pol[2]]
results$lambda[idx_opt_pol[2]]
results$lambda[idx_opt_pol[2]]
idx_opt_obj
idx_opt <- idx_opt_pol[1]
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
idx_opt <- idx_opt_pol[1]
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
geom_points_fct(results, idx_opt, df_complete, option)
results$lambda[idx_opt_pol[1]]
which(results$policy_value==max(results[results$constraint<=0]$policy_value))
results[results$constraint<=0]$policy_value
results[results$constraint<=0,]$policy_value
which(results$policy_value==max(results[results$constraint<=0,]$policy_value))
which.max(results[results$constraint<=0,]$policy_value))
which.max(results[results$constraint<=0,]$policy_value)
results$policy_value[234,]
results$policy_value[234]
results$lambda[234]
results$beta[234]
idx_opt_pol <- which.max(results[results$constraint<=0,]$policy_value)
idx_opt_pol
idx_opt_obj <- which.max(results[constraint<=0,]$obj)
idx_opt_obj <- which.max(results[results$constraint<=0,]$obj)
idx_opt_obj
idx_opt <- idx_opt_pol
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
results$lambda[idx_opt]
valid_idx <- which(results$constraint <= 0)  # Get indices of valid rows
idx_opt_pol <- valid_idx[which.max(results$policy_value[valid_idx])]
idx_opt_obj <- valid_idx[which.max(results$obj[valid_idx])]
idx_opt_pol
idx_opt_obj
idx_opt_pol <- which(results$policy_value == max(results$policy_value[results$constraint <= 0]))
idx_opt_obj <- which(results$obj == max(results$obj[results$constraint <= 0]))
idx_opt_pol
idx_opt_obj
results$lambda
results$lambda[30]
results$beta[30]
idx_opt_pol
idx_opt_pol[1]
results$lambda[328]
results$beta[328]
idx_opt <- idx_opt_pol[1]
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
idx_opt <- idx_opt_obj
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
results$beta[idx_opt]
results$lambda[idx_opt]
results$obj[idx_opt]
results$risk[idx_opt]
idx_opt <- idx_opt_pol[1]
results$risk[idx_opt]
results$obj[idx_opt]
results$constraint[idx_opt]
results$constraint[idx_opt_obj]
results$obj[idx_opt_obj]
results$obj[idx_opt_pol]
results$policy_value[idx_opt_pol]
results$policy_value[idx_opt_obj]
idx_opt <- idx_opt_obj
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
geom_points_fct(results, idx_opt, df_complete, option)
setting
gamma_lambda_plot(results, option, df_complete)
results$beta[idx_opt_pol[1]]
beta_discr <- c(idx_opt_pol, idx_opt_obj)
beta_discr
beta_discr <- c(idx_opt_obj, idx_opt_pol)
beta_discr
plots <- lapply(beta_discr, function(x) gamma_plot_funct(beta_res$optimal_x[[x]], beta_res$lambda[[x]], beta_res$beta[[x]],option, df))
beta_res <- results %>%
group_by(beta) %>%
filter(obj == max(obj)) %>%
ungroup()
beta_res <- results %>%
group_by(beta) %>%
filter(obj == max(obj)) %>%
ungroup()
beta_res[beta_discr]
beta_res[beta_discr[1],]
beta_discr
plots <- lapply(beta_discr, function(x) gamma_plot_funct(results$optimal_x[[x]], results$lambda[[x]], results$beta[[x]],option, df_complete))
plots_no_legend <- lapply(plots, function(p) p + theme(legend.position = "none"))
legend <- get_legend(plots[[1]])
combined_plots <- plot_grid(plotlist = plots_no_legend, ncol = 5, nrow = 2, align = "hv")
final_plot_b <- plot_grid(combined_plots, legend, ncol=1, rel_heights = c(5,2))
print(final_plot_b)
ggsave(paste0("images/oracular/geom_beta_plot_",option[1],"_",option[2],".pdf"),final_plot_b)
animation_plot(results[which(results$beta==results$beta[idx_opt]),], results$lambda[which(results$beta==results$beta[idx_opt])], option, df_complete)
animation_plot(results[which(results$beta==results$beta[idx_opt]),], results$lambda[which(results$beta==results$beta[idx_opt])], option, df_complete)
res <- results %>% filter(constraint<=0)
# Setting
setting<- "IVF_1"
# Constraint-tolerance parameter
alpha<- 0.1 #0.5 #0.1 #0.05
epsilon <- 0.1
#### Generate synthetic data ####
option <- option_det(setting,"_")
exp <- data_gen(n,option)
df_complete<- exp[[1]]
###
true_cate_Y <- (df_complete$y1-df_complete$y0)
true_cate_Z <- df_complete$p1-df_complete$p0
### Plot synthetic_setting scenario
synthetic_setting_plot(df_complete, option)
# Grid search candidates
## Beta
beta_values <- seq(1e-6,2, 0.08)
## Lambda
lambda_values <- seq(0,10,0.1)
pi_opt <- ifelse(true_cate_Y>0,1,0)
mean(pi_opt*df_complete$y1 + (1-pi_opt)*df_complete$y0)
# Optimization: Find the x that minimizes the objective for each lambda
library(optimx)
results <- expand.grid(lambda = lambda_values, beta = beta_values, optimal_x = NA, risk = NA, constraint=NA, obj=NA, policy_value=NA)
covariates <- df_complete %>% select(starts_with("X"))
results$optimal_x <- vector("list", nrow(results))
for (beta in beta_values) {
for (lambda in lambda_values) {
# Get the current row index for this (lambda, beta) pair
idx <- which(results$lambda == lambda & results$beta == beta)
optim_result <- optim(
par = delta_Y(covariates, option),
fn = function(x) L(x, covariates, lambda, option, beta, alpha),
method = "L-BFGS-B",
lower = -1, upper = 1
)
# Store results
results$optimal_x[[idx]] <- optim_result$par
results$risk[idx] <- R_p0(optim_result$par, covariates, option)
results$constraint[idx] <- S_p0(optim_result$par, covariates, option, beta)
results$obj[idx] <- L(optim_result$par, covariates, lambda, option, beta, alpha)
results$policy_value[idx] <- policy_values(optim_result$par, c(df_complete$y1,df_complete$y0), beta)
# Stop increasing lambda if constraint is met
if (results$constraint[idx] < -epsilon) {
break  # Exit the loop for this beta, move to the next beta
}
}
}
results <- na.omit(results)
write.csv(results %>% select(-optimal_x), paste0("opt_results/",setting,".csv"))
results
idx_opt_pol <- which(results$policy_value == max(results$policy_value[results$constraint <= 0]))
idx_opt_pol
idx_opt_obj
results$lambda[idx_opt_pol[1]]
results$beta[idx_opt_pol[1]]
results$beta[idx_opt_pol[2]]
results$beta[idx_opt_pol[2]]
results$lambda[idx_opt_pol[2]]
results$beta[idx_opt_obj]]
results$beta[idx_opt_obj]
results$lambda[idx_opt_obj]
idx_opt <- idx_opt_pol[1]
lambda_evol(results %>% select(-optimal_x),option, results$lambda[idx_opt], results$beta[idx_opt])
results$lbj[idx_opt_pol[1]]
results$obj[idx_opt_pol[1]]
results$obj[idx_opt_pol[2]]
results$obj[idx_opt_obj]
geom_points_fct(results, idx_opt, df_complete, option)
idx_opt <- idx_opt_pol[1]
geom_points_fct(results, idx_opt, df_complete, option)
gamma_lambda_plot(results, option, df_complete)
animation_plot(results[which(results$beta==results$beta[idx_opt]),], results$lambda[which(results$beta==results$beta[idx_opt])], option, df_complete)
